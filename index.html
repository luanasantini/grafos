<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Estruturas de Dados & Algoritmos</title>
    <link rel="stylesheet" href="styles.css">
    <link
        href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&family=Quicksand:wght@300;400;500&display=swap"
        rel="stylesheet">
</head>

<body>
    <header>
        <h1>Arv√≥res bin√°rias </h1>
        <p class="subtitle">Algoritmos e complexidade</p>
    </header>

    <nav>
        <ul>
            <li><a href="#arvores">√Årvores</a></li>
            <li><a href="#arvoresbinarias">√Årvores Bin√°rias</a></li>
            <li><a href="#arvoresbuscabinaria">√Årvores Bin√°rias de Busca</a></li>
            <li><a href="#percursoarvores">Percurso em √Årvores</a></li>
            <li><a href="#operacoes">Opera√ß√µes</a></li>
            <li><a href="#arvoreavl">√Årvore AVL</a></li>
            <li><a href="#balanceamento">Balanceamento</a></li>
        </ul>
    </nav>

    <main>

        <section id="arvores" class="topic">
            <h2>‚ú® √Årvores</h2>
            <p>Arvores s√£o estruturas de dados hier√°rquicas nas quais os dados s√£o armazenados por n√≥s conectados por
                arestas, representando rela√ß√µes pai-filho. Elas s√£o amplamente utilizadas em ci√™ncia da computa√ß√£o para
                organizar dados de forma eficiente, permitindo opera√ß√µes r√°pidas de busca, inser√ß√£o e remo√ß√£o.
                <br>
                <div class="split-content">
                    <div class="content-left">
                        <h3 class="content-title">Caracter√≠sticas Principais:</h3>
                        ‚Ä¢ O primeiro n√≥ √© chamado de¬†n√≥ raiz. Este n√≥ n√£o tem um n√≥ pai e serve como o ponto de origem
                        para
                        todos os outros n√≥s da √°rvore<br>
                        ‚Ä¢ Os n√≥s folha, ou terminais, s√£o os n√≥s que n√£o t√™m filhos. Eles representam as extremidades
                        dos
                        ramos da √°rvore, constituindo o final de um caminho espec√≠fico.<br>
                        ‚Ä¢ N√≥s que t√™m pelo menos um filho s√£o chamados de n√≥s internos. Estes constituem os pontos de
                        bifurca√ß√£o na √°rvore, representando decis√µes ou ramifica√ß√µes na estrutura.<br>
                        ‚Ä¢ A forma mais comum de representar uma √°rvore em mem√≥ria √© utilizando aloca√ß√£o din√¢mica,
                        utilizando
                        uma refer√™ncia para sua raiz que guarda a chave (dado) e uma refer√™ncia para a raiz das
                        sub√°rvores
                        esquerda e direita.<br>
                        ‚Ä¢ √Årvores s√£o estruturas de dados muito vers√°teis e a abstra√ß√£o mais utilizada para representar
                        o n√≥
                        de uma √°rvore √© o agregado heterog√™neo, comumente chamado de <b>registro (record)</b> ou
                        <b>estrutura (struct)</b> nas linguagens de programa√ß√£o. O agregado heterog√™neo √© capaz de
                        armazenar
                        objetos de dados de tipos diferentes acessando-os atrav√©s do mesmo identificador e
                        distinguindo-os
                        atrav√©s de um seletor.<br>
                        <div class="image-container">
                            <img src="https://lh7-us.googleusercontent.com/jECv80Ugul9kfFG0vTF6qGin4EwN3_fkIGnOf_ah0b-1gmLl9hifVlwTE5RE4fwUhluWIgfL2HHq5HxSXVFGd06SVxzTD0cCyK0bbZeSmLB6pRXxDjdq7kkhWLZcnHTBZiaIGgPakg1l3nfFp_wQk3O4OAa9f1hRaq6vRjILH4AF6ULhB_yNM4CjngdVag"
                                alt="Estrutura de √Årvore Bin√°ria" class="tree-image">
                        </div>
                        <center>A altura de uma √°rvore √© a profundidade m√°xima de um n√≥ da √°rvore.</center><br>


                    </div>
                </div>
            </p>

            <div class="code-examples">
                <div class="code-block">
                    <h3>Estrutura de √Årvore</h3>
                    <div class="image-container">
                        <img src="https://pythonhelp.wordpress.com/wp-content/uploads/2015/01/image06.png"
                            alt="Estrutura de √Årvore Bin√°ria" class="tree-image">
                    </div>
                    Na figura acima, o¬†n√≥ raiz¬†√© o 8, e ele tem como filhos os n√≥s de chave 4, 2, 9 e 1. O n√≥ 4 √© pai
                    dos n√≥s 6 e 7. Estes dois, assim como os n√≥s de chave 5, 2 e 1, s√£o chamados de¬†folhas¬†por n√£o terem
                    filhos (ou seja, seus filhos s√£o nulos).
                    <div class="image-container">
                        <img src="https://lh7-us.googleusercontent.com/WOjfHPnu_65FACqq3x14bMcGMaVGba0MlQ2-ZSRB5VVdZ9TO98HJbkVy998cF2dk_ZFQhyuK9U-5ZQNOEgxSVNwyP4YAgkLzGyWxCAI2zYAa3n4KRJrbfkRzf1hRLc3MAI3fIo5JXG9W9T9sIe-YT7Ljie9bhZyaE5v9zwAHeHcp_xfUsLkUeWMvL3inMA"
                            alt="Estrutura de √Årvore Bin√°ria" class="tree-image">
                    </div>
                </div>
            </div>
        </section>

        <section id="arvoresbinarias" class="topic">
            <h2>‚ú® √Årvores Bin√°rias</h2>
            <p>Uma √°rvore bin√°ria √© um tipo especial de √°rvore onde cada n√≥ tem no m√°ximo dois filhos: um filho esquerdo
                e um filho direito. √â uma das estruturas de dados mais fundamentais em computa√ß√£o.
                <br>
                <div class="image-container">
                    <img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg9Ho7ZYW5fMMsQsrrZgzXh5eCv6r-mdgv5hEgps0akglNfNAISeJe67z4_7mQAWAFsHn39fyN0U8spTspM4KvHKHUaiuLLSavJ3CY3uQErm9cG3pMOwA_daw8X92xWG85sPmzttvbYgw/s1600/tiposDeArvoreBinaria.png"
                        alt="Estrutura de √Årvore Bin√°ria" class="tree-image">
                </div>
                <div class="split-content">
                    <div class="content-left">
                        <h3 class="content-title">Caracter√≠sticas Principais:</h3>
                        ‚Ä¢ O filho √† esquerda e o filho √† direita s√£o distintos, permitindo que a √°rvore cres√ßa de
                        maneira
                        organizada<br>
                        ‚Ä¢ Cada n√≥, exceto o n√≥ raiz, tem um n√≥ pai que o precede na hierarquia<br>
                        ‚Ä¢ Uma √°rvore bin√°ria pode ser vazia ou composta pelo n√≥ raiz + as sub√°rvores esquerdas e
                        sub√°rvores
                        direitas, que tamb√©m s√£o √°rvores bin√°rias<br>
            </p>
            </div>
            </div>

            <div class="code-examples">
                <div class="code-block">
                    <h3>Estrutura de √Årvore Bin√°ria</h3>
                    <div class="image-container">
                        <img src="https://pythonhelp.wordpress.com/wp-content/uploads/2015/01/image10.png"
                            alt="Estrutura de √Årvore Bin√°ria" class="tree-image">
                    </div>
                    Na imagem acima, o n√≥ ‚Äú1‚Äù √© a raiz da √°rvore. A sub√°rvore esquerda √© composta pelos n√≥s ‚Äú2‚Äù, ‚Äú4‚Äù e
                    ‚Äú5‚Äù e a sub√°rvore direita √© composta pelos n√≥s ‚Äú3‚Äù e ‚Äú6‚Äù. Os n√≥s ‚Äú2‚Äùe ‚Äú3‚Äù s√£o os n√≥s raiz das
                    sub√°rvores.
                </div>
            </div>

            </p>

            <div class="code-examples">

            </div>
        </section>

        <section id="arvoresbuscabinaria" class="topic">
            <h2>‚ú® √Årvores Bin√°rias de Busca</h2>
            <p>As¬†√Årvores Bin√°rias de Busca¬†s√£o √°rvores onde todos os n√≥s pertencentes √† sub√°rvore esquerda (de qualquer
                n√≥) possuem chave <b>menor que a chave do mesmo</b>, e em que os n√≥s da sub√°rvore direita possuem chave
                <b>maior que a chave do mesmo</b>.¬†Essa propriedade deve ser v√°lida para todas as sub√°rvores,
                possibilitando a realiza√ß√£o de buscas mais eficientes.
                <br>
                <div class="split-content">
                    <div class="content-left">
                        <h3 class="content-title">Caracter√≠sticas Principais:</h3>
                        ‚Ä¢ A escolha da dire√ß√£o de busca s√≥ depende da chave que se procura e da chave que o n√≥ atual
                        possui
                        (se a chave procurada for menor do que a chave do n√≥ atual, v√° para a esquerda; se for maior, v√°
                        para a direita).<br>
                        ‚Ä¢ Permite busca, inser√ß√£o e exclus√£o eficientes<br>
                        ‚Ä¢ N√£o √© necessariamente balanceada<br>
                        ‚Ä¢ No pior caso (√°rvore degenerada), o desempenho √© O(n)<br>
                        ‚Ä¢ No melhor caso (balanceada), o desempenho √© O(log n)<br>
                    </div>
                </div>
            </p>

            <div class="code-examples">
                <div class="code-block">
                    <h3>Exemplo em Python</h3>
                    <pre><code>
# Exemplo de uso
# Criando uma √°rvore simples
raiz = No(10)
raiz.esquerda = No(5)
raiz.direita = No(15)


                        class No:
    def __init__(self, chave):
        self.chave = chave
        self.esquerda = None
        self.direita = None

def buscar(raiz, chave):
    if raiz is None or raiz.chave == chave:
        return raiz  # Encontrou ou chegou ao fim sem encontrar
    if chave < raiz.chave:
        return buscar(raiz.esquerda, chave)
    else:
        return buscar(raiz.direita, chave)

# Buscando uma chave
resultado = buscar(raiz, 15)
if resultado:
    print(f"Chave {resultado.chave} encontrada!")
else:
    print("Chave n√£o encontrada.")
                    </code></pre>
                </div>

                <div class="split-content">
                    <div class="content-left">
                        ‚Ä¢ O algoritmo de busca compara a chave procurada com a raiz:<br>
                        - Se for igual, a busca termina.<br>
                        - Se for menor, executa o algoritmo de busca recursivamente na sub√°rvore esquerda.<br>
                        - Se for maior, executa o algoritmo de busca recursivamente busca na sub√°rvore direita.<br>

                        ‚Ä¢ O algoritmo de busca √© utilizado tamb√©m nas opera√ß√µes de inser√ß√£o e remo√ß√£o nas √°rvores
                        bin√°rias de busca, exigindo:<br>
                        ‚Ä¢ Um indicador booleano para saber se a chave foi encontrada.<br>
                        ‚Ä¢ Uma refer√™ncia ao pai do n√≥ onde a chave est√° (ou estaria).<br>
                        ‚Ä¢ Se a chave buscada n√£o est√° armazenada na √°rvore, o algoritmo retorna o n√≥ onde a busca
                        falhou, ou seja, aquele n√≥ cuja sub√°rvoreque deveria ser explorada no pr√≥ximo passo da busca √©
                        vazio.<br>
                    </div>
                    <br>
                    <div class="content-left">
                        Na busca, existem algumas situa√ß√µes especiais:<br><br>
                        1. Quando a chave buscada est√° na raiz, o n√≥ que cont√©m a chave n√°o tem pai, por isso, o
                        algoritmo de busca dever√° retornar NULO na refer√™ncia para o pai<br>
                        <br>
                        2. Quando a busca √© realizada numa √°rvore vazia, o algoritmo dever√° retornar NULO para o n√≥ que
                        cont√©m a chave, NULO para refer√™ncia do n√≥ que √© pai do n√≥ que cont√©m a chave buscada e o
                        booleano FALSO.

                    </div>
                </div>
            </div>

        </section>

        <section id="percursoarvores" class="topic">
            <h2>‚ú® Percurso em √Årvores</h2>
            <p>Um percurso √© a visita sistem√°tica aos elementos de uma estrutura de dados.
                Existem diferentes formas de percorrer uma √°rvore, cada uma com aplica√ß√µes espec√≠ficas.
                <br>
                Obs.: Visitar significa realizar uma opera√ß√£o e n√£o acessar o conte√∫do armazenado no elemento da
                estrutura de dados. Ou seja, especificamente para √°rvores, acessar um n√≥ da √°rvore n√£o configura uma
                visita.
                <br>
                <div class="split-content">
                    <div class="content-left">
                        <h3 class="content-title">Caracter√≠sticas Principais:</h3>
                        - Permite acessar todos os n√≥s da √°rvore sistematicamente<br>
                        - Diferentes ordens de percurso resultam em diferentes sequ√™ncias<br>
                        - Fundamental para processamento de dados em √°rvores<br>
                        - Pode ser recursivo ou iterativo<br>
                        - Complexidade: O(n) onde n √© o n√∫mero de n√≥s
                    </div>
                </div>
                </div>
            </p>

            <h3>üå≥ Percurso em Pr√©-ordem (Raiz, Esquerda, Direita)</h3><br>
            <p><b>Etapa 1</b>: Visita-se a raiz.<br>

                <b>Etapa 2</b>: Percorre-se a sub√°rvore esquerda de *T*, em pr√©-ordem.<br>

                <b>Etapa 3</b>: Percorre-se a sub√°rvore direita de *T*, em pr√©-ordem.<br>

                - Para realizar o percurso em pr√©-ordem, s√£o necess√°rios tr√™s acessos ao n√≥.<br>

                - Se temos *n* n√≥s em uma √°rvore, o n√∫mero de acesso ao n√≥ √© 3*n*. Assim, a complexidade computacional
                do
                percurso em pr√©-ordem √© *O(n)*.</p>
            <div class="code-examples">
                <div class="code-block">
                    <h3>Exemplo em Python</h3>
                    <pre><code>
def preordem(raiz):
    if raiz is not None:
        print(raiz.valor, end=" ")     # Raiz
        preordem(raiz.esquerdo)        # Esquerda
        preordem(raiz.direito)         # Direita
                    </code></pre>
                </div>
            </div>

            <h3><br>üå≥ Percurso em Ordem (Esquerda, Raiz, Direita)</h3><br>
            <p><b>Etapa 1</b>: Percorre-se a sub√°rvore esquerda de T, em ordem sim√©trica.<br>

                <b> Etapa 2</b>: Visita-se a raiz.<br>

                <b>Etapa 3</b>: Percorre-se as sub√°rvores direita de T, em ordem sim√©trica.<br>

                - A an√°lise de complexidade √© an√°loga a feita no algoritmo do percurso em pr√©-ordem, e a √∫nica diferen√ßa
                √© a ordem das visitas.<br></b>

                - Sendo assim, a complexidade computacional do algoritmo para percurso em ordem sim√©trica √© *O(n)*.</p>
            <div class="code-examples">
                <div class="code-block">
                    <h3>Exemplo em Python</h3>
                    <pre><code>
def emOrdem(raiz):
    if raiz is not None:
        emOrdem(raiz.esquerdo)         # Esquerda
        print(raiz.valor, end=" ")     # Raiz
        emOrdem(raiz.direito)          # Direita
                    </code></pre>
                </div>
            </div>

            <h3><br>üå≥ Percurso em P√≥s-ordem (Esquerda, Direita, Raiz)</h3><br>
            <p>

                <b>Etapa 1</b>: Percorre-se a sub√°rvore esquerda de *T*, em p√≥s-ordem.<br>

                <b>Etapa 2</b>: Percorre-se a sub√°rvore direita de *T*, em p√≥s-ordem.<br>

                <b>Etapa 3</b>: Visita-se a raiz.<br>

                - A an√°lise da complexidade √© totalmente an√°loga √† an√°lise feita para pr√©-ordem e a ordem sim√©trica, o
                que faz com que o algoritmo tenha complexidade O(n).</p>
            <div class="code-examples">
                <div class="code-block">
                    <h3>Exemplo em Python</h3>
                    <pre><code>
def posOrdem(raiz):
    if raiz is not None:
        posOrdem(raiz.esquerdo)        # Esquerda
        posOrdem(raiz.direito)         # Direita
        print(raiz.valor, end=" ")     # Raiz
                    </code></pre>
                </div>
            </div>
            <div class="image-container">
                <img src="https://pythonhelp.wordpress.com/wp-content/uploads/2015/01/image12.png"
                    alt="Estrutura de √Årvore Bin√°ria" class="tree-image">
            </div>
        </section>

        <section id="operacoes" class="topic">
            <h2>‚ú® Opera√ß√µes em √Årvores</h2>
            <p>Opera√ß√µes em √°rvores s√£o os procedimentos fundamentais de conjuntos din√¢micos para manipular dados
                armazenados em estruturas de √°rvore. As opera√ß√µes principais s√£o sele√ß√£o, inser√ß√£o, remo√ß√£o e a pr√≥pria
                busca.<br>
                <div class="split-content">
                    <div class="content-left">
                        <h3 class="content-title">Caracter√≠sticas Principais:</h3>
                        ‚Ä¢ As opera√ß√µes levam um tempo proporcional √† altura da √°rvore.<br>
                        ‚Ä¢ Para uma √°rvore completa de n n√≥s, tais opera√ß√µes levam um tempo proporcional a O(log n).<br>
                        ‚Ä¢ Se a √°rvore for uma lista de n√≥s (ou seja, degenerada ou √°rvore zig-zag), as opera√ß√µes podem
                        levar
                        O(n).<br>
            </p>
            </div>
            </div>

            <br>

            <h3>üå≥ Inser√ß√£o</h3><Br>
            <p>- A inser√ß√£o ocorre sempre em um novo n√≥ folha, respeitando a regra: menores √† esquerda, maiores √†
                direita.<br>
                - Antes de inserir, √© feita uma busca pela chave:<br>
                - Se a chave j√° existe, n√£o √© inserida.<br>
                - Se n√£o existe, a busca retorna o n√≥ pai onde o novo n√≥ ser√° ligado.<br>
                - Caso especial: se a √°rvore estiver vazia, o novo n√≥ vira a raiz.<br>
                - A inser√ß√£o percorre a √°rvore como na busca, parando ao encontrar um n√≥ folha sem o filho
                correspondente.<br>
                - A nova chave √© inserida como filho √† esquerda se for menor, ou √† direita se for maior.<br><br>
                üìä <b>Complexidade:</b><br><br>
                - A inser√ß√£o depende da busca, que tem complexidade O(n) no pior caso (√°rvore desbalanceada).<br>
                - A opera√ß√£o de inserir o n√≥ ap√≥s a busca √© feita em tempo constante O(1).
            </p>
            <div class="code-examples">
                <div class="code-block">
                    <h3>Exemplo em Python</h3>
                    <pre><code>
def inserir(raiz, valor):
    if raiz is None:
        return Node(valor)
    
    if valor < raiz.valor:
        raiz.esquerdo = inserir(raiz.esquerdo, valor)
    elif valor > raiz.valor:
        raiz.direito = inserir(raiz.direito, valor)
    
    return raiz

# Complexidade: O(log n) em m√©dia, O(n) no pior caso
                    </code></pre>
                </div>
            </div>
            <br><br>
            <h3>üå≥ Remo√ß√£o</h3><br>
            <p>A remo√ß√£o √© mais complexa que a inser√ß√£o. H√° tr√™s casos: remover folha (simples), remover com um filho
                (simples) e remover com dois filhos (requer reestrutura√ß√£o).


                A remo√ß√£o de um n√≥ pode ocorrer em tr√™s casos distintos:<br><br>
                - <b>N√≥ folha (sem filhos):</b><br><br>
                - Basta desconectar o n√≥ do seu pai.<br>
                - Exemplo: remover o n√≥ 4 ‚Üí left do n√≥ 6 aponta para None.<br>
                <br>
                - <b>N√≥ com um filho:</b><br><br>
                - O pai do n√≥ passa a apontar diretamente para o √∫nico filho do n√≥ removido.<br>
                - Exemplo: remover o n√≥ 10 ‚Üí n√≥ 8 aponta para o n√≥ 14.<br>
                <br>
                - <b>N√≥ com dois filhos:</b><br><br>
                - Substitu√≠mos o n√≥ pelo menor valor da sub√°rvore direita (o sucessor).<br>
                - Exemplo: remover o n√≥ 3 ‚Üí substitu√≠do pelo n√≥ 4 (mais √† esquerda da sub√°rvore direita).<br>
                <br>
                üìä <b>Complexidade:</b><br><br>
                Em todos os casos, a opera√ß√£o de remo√ß√£o depende da busca, que tem custo O(n) no pior caso (√°rvore
                desbalanceada). As demais opera√ß√µes s√£o simples.
            </p>
            <div class="code-examples">
                <div class="code-block">
                    <h3>Exemplo em Python</h3>
                    <pre><code>
def remover(raiz, valor):
    if raiz is None:
        return None
    
    if valor < raiz.valor:
        raiz.esquerdo = remover(raiz.esquerdo, valor)
    elif valor > raiz.valor:
        raiz.direito = remover(raiz.direito, valor)
    else:
        # Caso 1: Folha (sem filhos)
        if raiz.esquerdo is None and raiz.direito is None:
            return None
        # Caso 2: Um filho
        if raiz.esquerdo is None:
            return raiz.direito
        if raiz.direito is None:
            return raiz.esquerdo
        # Caso 3: Dois filhos
        # encontrar sucessor e fazer rearranjo
    
    return raiz

# Complexidade: O(log n) em m√©dia, O(n) no pior caso
                    </code></pre>
                </div>
            </div>
        </section>

        <section id="arvoreavl" class="topic">
            <h2>‚ú® √Årvore AVL</h2>
            <p></p>
            <div class="split-content">
                <div class="content-left">
                    <h3 class="content-title">Caracter√≠sticas Principais:</h3>
                    ‚Ä¢ Uma √°rvore bin√°ria de busca √© uma AVL quando, para qualquer um de seus n√≥s, a diferen√ßa entre as
                    alturas de suas sub√°rvores direita e esquerda √© no m√°ximo 1 (ou seja, deve ser equilibrada -
                    BALANCEADA)<br>
                    ‚Ä¢ √â uma estrutura de dados completamente din√¢mica que suporte inser√ß√µes, remo√ß√µes e buscas em O(log
                    n).<br>
                    ‚Ä¢ A altura m√≠nima de uma √°rvore AVL √© proporcional O(l*og n)*. Ou seja, suas opera√ß√µes levam tempo
                    O(log n).<Br>
                    ‚Ä¢ As √°rvores completas s√£o AVL.<br>
                    ‚Ä¢ Caso a √°rvore esteja desbalanceada, podemos balance√°-la atrav√©s de rota√ß√µes.
                </div>
            </div>

            <h3>üå≥ Busca, Inser√ß√£o e Remo√ß√£o em √Årvore AVL</h3>
            <p>A inser√ß√£o e remo√ß√£o em AVL s√£o similares √† busca em √°rvore bin√°ria, mas ap√≥s cada opera√ß√£o, o algoritmo
                verifica o fator de balanceamento e realiza rota√ß√µes se necess√°rio para manter a √°rvore
                balanceada.<br><br>

                <b>‚ûñ Busca em AVL:</b><Br><br>

                - √Årvores AVL s√£o √°rvores bin√°rias de busca, ou seja, segume o mesmo algoritmo da √°rvore bin√°ria de busca.<br>
                - Complexidade: nas √°rvores AVL, as piores √°rvores s√£o as √°rvores de Fibonacci que t√™m altura proporcional a log n, sendo assim, a complexidade do algoritmo da busca, quando aplicado em √°rvores AVL, √© O(log n). <br><br>

                <b>‚ûñ Inser√ß√£o em AVL:</b><Br><br>
                - A inser√ß√£o em √°rvore AVL segue o mesmo algoritmo da √°rvore bin√°ria de busca.<br>
                - Se a √°rvore se desbalancear com a inser√ß√£o, √© corrigida com rota√ß√µes simples, que t√™m custo O(1).
                - Por conta do balanceamento evita a forma√ß√£o de √°rvores "zig-zag" (desbalanceadas).<br>
                - Mesmo no pior caso, s√£o necess√°rias no m√°ximo O(log n) rota√ß√µes.<br><br>

                <b>‚ûñ Remo√ß√£o em AVL:</b><Br><br>

                - A remo√ß√£o tamb√©m pode exigir rebalanceamento por rota√ß√µes at√© a raiz.<br>
                - Cada rota√ß√£o √© simples (O(1)), e no m√°ximo O(log n) rota√ß√µes s√£o feitas.<br>
                - O pior caso da remo√ß√£o √© a remo√ß√£o da folha menos profunda de uma √°rvore de Fibonacci. Neste caso, realizamos todas as rota√ß√µes da folha removida at√© a raiz.<br>

            </p>
            <div class="code-examples">
                <div class="code-block">
                    <h3>Exemplo em Python (Inser√ß√£o)</h3>
                    <pre><code>
class AVLNode:
    def __init__(self, valor):
        self.valor = valor
        self.altura = 1
        self.esquerdo = None
        self.direito = None

def inserir_avl(raiz, valor):
    if raiz is None:
        return AVLNode(valor)
    
    if valor < raiz.valor:
        raiz.esquerdo = inserir_avl(raiz.esquerdo, valor)
    elif valor > raiz.valor:
        raiz.direito = inserir_avl(raiz.direito, valor)
    else:
        return raiz
    
    # Atualizar altura
    raiz.altura = 1 + max(obter_altura(raiz.esquerdo),
                          obter_altura(raiz.direito))
    
    # Calcular fator de balanceamento
    fator = obter_fator(raiz)
    
    # Rota√ß√µes necess√°rias...
    # Esquerda-Esquerda, Direita-Direita, etc.
    
    return raiz

# Complexidade: O(log n) garantido
                    </code></pre>
                </div>
            </div>
        </section>

        <section id="balanceamento" class="topic">
            <h2>‚ú® Balanceamento de √Årvores Bin√°rias</h2>
            <p>O balanceamento de √°rvores bin√°rias √© uma t√©cnica fundamental para manter a efici√™ncia das opera√ß√µes. Uma √°rvore desbalanceada pode degenerar em uma lista ligada, degradando o desempenho para O(n). Diferentes estrat√©gias de balanceamento garantem que a altura permane√ßa logar√≠tmica.
                <br>
            <div class="split-content">
                <div class="content-left">
                    <h3 class="content-title">Caracter√≠sticas Principais:</h3><br>
                    - Uma √°rvore balanceada mant√©m a diferen√ßa de altura entre sub√°rvores m√≠nima<br>
                    - Rota√ß√µes (esquerda e direita) s√£o usadas para rebalancear<br>
                    - Fator de balanceamento: altura(esquerda) - altura(direita)<br>
                    - Garante complexidade O(log n) para busca, inser√ß√£o e remo√ß√£o<br>
                    - Exemplos: AVL, Red-Black, B-trees<br>
                </div>
            </div><br>
            </p>

            <h3>üå≥ Rota√ß√µes em √Årvores</h3>
            <p>As rota√ß√µes s√£o opera√ß√µes fundamentais usadas para rebalancear √°rvores. Existem dois tipos principais: rota√ß√µes simples (esquerda ou direita) e rota√ß√µes duplas (esquerda-direita ou direita-esquerda).</p>
            
            <div class="code-examples">
                <div class="code-block">
                    <h3>Rota√ß√£o Simples (Python)</h3><br>
                    <pre><code>
def rotacao_direita(no):
    """Rota√ß√£o simples para direita"""
    novo_raiz = no.esquerdo
    no.esquerdo = novo_raiz.direito
    novo_raiz.direito = no
    
    # Atualizar alturas
    no.altura = 1 + max(obter_altura(no.esquerdo), obter_altura(no.direito))
    novo_raiz.altura = 1 + max(obter_altura(novo_raiz.esquerdo), obter_altura(novo_raiz.direito))
    
    return novo_raiz

def rotacao_esquerda(no):
    """Rota√ß√£o simples para esquerda"""
    novo_raiz = no.direito
    no.direito = novo_raiz.esquerdo
    novo_raiz.esquerdo = no
    
    # Atualizar alturas
    no.altura = 1 + max(obter_altura(no.esquerdo), obter_altura(no.direito))
    novo_raiz.altura = 1 + max(obter_altura(novo_raiz.esquerdo), obter_altura(novo_raiz.direito))
    
    return novo_raiz
                    </code></pre>
                </div>
            </div><Br>

            <h3>üå≥ Rota√ß√µes Duplas</h3><br>
            <p>Rota√ß√µes duplas s√£o necess√°rias quando um desbalanceamento √© causado por um n√≥ na dire√ß√£o oposta. Combinam duas rota√ß√µes simples em sequ√™ncia.</p>
            
            <div class="code-examples">
                <div class="code-block">
                    <h3>Rota√ß√£o Dupla (Python)</h3>
                    <pre><code>
def rotacao_esquerda_direita(no):
    """Rota√ß√£o dupla: esquerda depois direita"""
    no.esquerdo = rotacao_esquerda(no.esquerdo)
    return rotacao_direita(no)

def rotacao_direita_esquerda(no):
    """Rota√ß√£o dupla: direita depois esquerda"""
    no.direito = rotacao_direita(no.direito)
    return rotacao_esquerda(no)

# Exemplo de uso em inser√ß√£o com balanceamento
def inserir_balanceado(raiz, valor):
    if raiz is None:
        return Node(valor)
    
    if valor < raiz.valor:
        raiz.esquerdo = inserir_balanceado(raiz.esquerdo, valor)
    else:
        raiz.direito = inserir_balanceado(raiz.direito, valor)
    
    # Calcular fator de balanceamento
    fator = obter_altura(raiz.esquerdo) - obter_altura(raiz.direito)
    
    # Caso esquerda-esquerda
    if fator > 1 and obter_fator(raiz.esquerdo) >= 0:
        return rotacao_direita(raiz)
    
    # Caso direita-direita
    if fator < -1 and obter_fator(raiz.direito) <= 0:
        return rotacao_esquerda(raiz)
    
    # Caso esquerda-direita
    if fator > 1 and obter_fator(raiz.esquerdo) < 0:
        return rotacao_esquerda_direita(raiz)
    
    # Caso direita-esquerda
    if fator < -1 and obter_fator(raiz.direito) > 0:
        return rotacao_direita_esquerda(raiz)
    
    return raiz
                    </code></pre>
                </div>
            </div>
        </section>
    </main>

    <footer>
        <p>üå∏ Luana Santini: Sistemas de Informa√ß√£o - Est√°cio Florian√≥polis - Matr√≠cula 202308416251üå∏</p>
    </footer>
</body>

</html>