<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Estruturas de Dados & Algoritmos</title>
    <link rel="stylesheet" href="styles.css">
    <link
        href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&family=Quicksand:wght@300;400;500&display=swap"
        rel="stylesheet">
</head>

<body>
    <header>
        <h1>Grafos</h1>
        <p class="subtitle">Algoritmos e complexidade</p>
    </header>

    <nav>
        <ul>
            <li><a href="#conceitos">Conceitos</a></li>
            <li><a href="#tipos">Tipos de Grafos</a></li>
            <li><a href="#buscas">Buscas</a></li>
            <li><a href="#algoritmos">Algoritmos</a></li>
            <li><a href="#aplicacoes">Aplicações</a></li>
        </ul>
    </nav>

    <main>

        <section id="conceitos" class="topic">
            <h2> Conceitos Fundamentais</h2>
            <p>Um grafo é uma estrutura de dados abstrata composta por um conjunto de vértices (também chamados de nós)
                e um conjunto de arestas que conectam pares de vértices. Os grafos são usados para modelar
                relacionamentos entre objetos e são fundamentais em ciência da computação.
                <br>
                <div class="split-content">
                    <div class="content-left">
                        <h3 class="content-title">Características Principais:</h3>
                        • <b>Vértices (Nós):</b> Elementos fundamentais do grafo que representam objetos ou entidades.<br>
                        • <b>Arestas:</b> Conexões entre pares de vértices que representam relacionamentos.<br>
                        • <b>Grau de um vértice:</b> Número de arestas incidentes ao vértice. Em grafos direcionados,
                        distinguem-se grau de entrada (in-degree) e grau de saída (out-degree).<br>
                        • <b>Caminho:</b> Sequência de vértices conectados por arestas.<br>
                        • <b>Ciclo:</b> Caminho que começa e termina no mesmo vértice.<br>
                        • <b>Componente Conexa:</b> Subconjunto de vértices onde existe caminho entre qualquer par.<br>
                        • <b>Peso:</b> Valor associado a uma aresta (em grafos ponderados).<br>
                        <div class="image-container">
                            <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/5b/6n-graf.svg/1024px-6n-graf.svg.png"
                                alt="Exemplo de Grafo" class="tree-image">
                        </div>
                        <center>Exemplo de um grafo simples com 6 vértices e 7 arestas</center><br>


                    </div>
                </div>
            </p>


        </section>

        <section id="tipos" class="topic">
            <h2> Tipos de Grafos</h2>
            <p>Existem vários tipos de grafos, cada um com características e aplicações específicas. A classificação
                depende de propriedades como direção, peso e estrutura das arestas.
                <br>
                <div class="split-content">
                    <div class="content-left">
                        <h3 class="content-title">Tipos de grafos</h3>
                        • <b>Grafo Direcionado (Dígrafo):</b> As arestas têm um sentido único e vão de um vértice para
                        outro.<br>
                        • <b>Grafo Não-Direcionado:</b> As arestas não têm direção, são bidirecionais e conectam vértices
                        de forma
                        simétrica.<br>
                        • <b>Grafo Ponderado:</b> Cada aresta possui valores associados a elas. Esses valores são chamados
                        de pesos, custos ou distância.<BR>
                        • <b>Grafo Não-Ponderado:</b> As arestas não possuem valores associados a elas<br>
                        • <b>Grafo Completo:</b> Existe uma aresta entre todo par de vértices.<br>
                        • <b>Grafo Cíclico:</b> Contém pelo menos um ciclo.<br>
                        • <b>Grafo Acíclico (DAG):</b> Não contém ciclos.<br>
                    </div>
                </div>

                <div class="code-examples">
                    <div class="code-block">
                        <h3>Grafos direcionados e não direcionados</h3>
                        <div class="image-container">
                            <img src="https://media.licdn.com/dms/image/v2/C4E12AQHfTMIkrjYPNQ/article-inline_image-shrink_400_744/article-inline_image-shrink_400_744/0/1625159712100?e=2147483647&v=beta&t=0fguq6qYhPupS8XG3nHShuOMKSt7N4oNMPf7_UY6fFA"
                                alt="Direção de grafos" class="tree-image">
                        </div>
                        <div class="content-left">
                            Na figura acima, na direita temos um grafo direcionado com vértices {A, B, C, D, E} e
                            arestas
                            representadas pelas setas. Cada aresta aponta de um vértice para outro, indicando uma
                            relação
                            direcionada. Por exemplo, a aresta de A para B indica uma conexão que vai de A para B.
                            Já na esquerda, temos um grafo não-direcionado com os mesmos vértices, mas as arestas são
                            representadas por linhas sem setas, indicando que a conexão entre os vértices é
                            bidirecional.
                            Por exemplo, a linha entre A e B indica que há uma conexão entre A e B que pode ser
                            percorrida
                            em ambos os sentidos.
                        </div>
                    </div>

                    <div class="code-block">
                        <h3>Grafos ponderados</h3>
                        <div class="image-container">
                            <img src="https://d33wubrfki0l68.cloudfront.net/e7598847793e60d1f80b49506ddb5b0b64f2b5be/3e048/wp-content/uploads/2006/01/grviz04113_001.png"
                                alt="Grafos ponderados" class="tree-image">
                        </div>
                        <div class="content-left">
                            Em um grafo ponderado, ao ir de um vértice a outro, procuramos o caminho onde a soma dos
                            valores
                            das arestas seja a menor possível, independente do número de arestas percorridas ou da
                            distância entre elas.
                            Neste grafo, por exemplo, o menor caminho de 0 a 3 não é a aresta 0–3, mas sim a aresta 0–2
                            e depois a aresta 2–3.
                        </div>


                    </div>

                </div>


                <div class="code-examples">
                    <div class="code-block">
                        <h3>Grafos completos</h3>
                        <div class="image-container">
                            <img src="https://upload.wikimedia.org/wikipedia/commons/e/e5/Grafo_completo.jpg"
                                alt="Grafos completos" class="tree-image">
                        </div>
                        <div class="content-left">
                            Um grafo completo é um grafo em que <b>todos os pares de vértices</b> distintos são
                            conectados por uma aresta. Isso significa que cada vértice tem uma aresta conectando-o a
                            todos os outros vértices do grafo. Um grafo completo com <i>n</i> vértices é denotado por
                            <i>Kn</i>.
                        </div>
                    </div>

                    <div class="code-block">
                        <h3>Grafos cíclicos</h3>
                        <div class="image-container">
                            <img src="https://www.luisllamas.es/images/20297/grafo-ciclo.webp" alt="Grafos cíclicos"
                                class="tree-image">
                        </div>
                        <div class="content-left">
                            Um grafo cíclico é um grafo que contém um ou mais caminhos que começam e terminam no mesmo
                            vértice, sem repetir outros vértices no processo, chamados de ciclos. Em outras palavras, em
                            alguma parte do grafo é possível percorrer uma sequência de arestas e retornar ao ponto de
                            partida, formando um ciclo fechado. Grafos acíclicos não possuem nenhum ciclo.
                        </div>


                    </div>

                </div><br>



            </p>

            <div class="code-examples">
                <div class="code-block">
                    <h3>Exemplo em Python - Classe Grafo</h3>
                    <pre><code>
class Grafo:
    def __init__(self, num_vertices):
        self.num_vertices = num_vertices
        self.lista_adjacencia = [[] for _ in range(num_vertices)]
    
    def adicionar_aresta(self, u, v, peso=1):
        """Adiciona uma aresta entre u e v"""
        self.lista_adjacencia[u].append((v, peso))
        # Para grafo não-direcionado, descomente:
        # self.lista_adjacencia[v].append((u, peso))

    def obter_vizinhos(self, vertice):
        """Retorna os vizinhos de um vértice"""
        return self.lista_adjacencia[vertice]

# Exemplo de uso
grafo = Grafo(5)
grafo.adicionar_aresta(0, 1, 4)
grafo.adicionar_aresta(0, 2, 2)
grafo.adicionar_aresta(1, 2, 1)
grafo.adicionar_aresta(1, 3, 5)
                    </code></pre>
                </div>

            </div>

        </section>

        <section id="buscas" class="topic">
            <h2> Buscas em Grafos</h2>
            <p>As buscas são operações fundamentais que permitem explorar todos os vértices de um grafo de forma
                sistemática. As duas principais estratégias são a busca em profundidade (DFS) e a busca em largura
                (BFS).
                <br>
                <div class="split-content">
                    <div class="content-left">
                        <h3 class="content-title">Características Principais:</h3>
                        • Permite acessar todos os vértices do grafo sistematicamente<br>
                        • Diferentes ordens de exploração resultam em diferentes sequências<br>
                        • Fundamental para processamento de dados em grafos<br>
                        • Pode ser implementada de forma recursiva ou iterativa<br>
                        • Complexidade: O(V + E) onde V é o número de vértices e E o número de arestas
                    </div>
                </div>
                </div>
            </p>

            <h3> Busca em Profundidade (DFS - Depth First Search)</h3><br>
            <p><b>Característica:</b> Explora o grafo indo o mais profundo possível antes de retroceder.<br>

                <b>Algoritmo:</b><br>
                1. Marca o vértice atual como visitado<br>
                2. Para cada vizinho não visitado, executa recursivamente DFS<br>
                3. Depois de explorar todos os vizinhos, retrocede<br>

                - Utiliza pilha (stack) ou recursão para manter controle da exploração<br>
                - Pode ser usada para detecção de ciclos, ordenação topológica e componentes fortemente conexas<br>
                - Complexidade: O(V + E) onde V é o número de vértices e E o número de arestas</p>
            <div class="code-examples">
                <div class="code-block">
                    <h3>Exemplo em Python - DFS Recursivo</h3>
                    <pre><code>
def dfs(grafo, vertice, visitado=None):
    if visitado is None:
        visitado = set()
    
    visitado.add(vertice)
    print(vertice, end=" ")  # Processa o vértice
    
    for vizinho, _ in grafo.lista_adjacencia[vertice]:
        if vizinho not in visitado:
            dfs(grafo, vizinho, visitado)

# Exemplo de uso
grafo = Grafo(5)
grafo.adicionar_aresta(0, 1)
grafo.adicionar_aresta(0, 2)
grafo.adicionar_aresta(1, 2)
grafo.adicionar_aresta(2, 0)
grafo.adicionar_aresta(2, 3)

dfs(grafo, 0)  # Saída: 0 1 2 3
                    </code></pre>
                </div>
            </div>

            <h3><br> Busca em Largura (BFS - Breadth First Search)</h3><br>
            <p><b>Característica:</b> Explora o grafo visitando todos os vértices no mesmo nível antes de ir para o
                próximo nível.<br>

                <b>Algoritmo:</b><br>
                1. Marca o vértice inicial como visitado e enfileira<br>
                2. Enquanto houver vértices na fila:<br>
                a. Remove o primeiro vértice da fila<br>
                b. Para cada vizinho não visitado, marca como visitado e enfileira<br>

                - Utiliza fila (queue) para manter controle da exploração<br>
                - Encontra o menor caminho em grafos não ponderados<br>
                - Complexidade: O(V + E) onde V é o número de vértices e E o número de arestas</p>
            <div class="code-examples">
                <div class="code-block">
                    <h3>Exemplo em Python - BFS</h3>
                    <pre><code>
from collections import deque

def bfs(grafo, inicio):
    visitado = set()
    fila = deque([inicio])
    visitado.add(inicio)
    
    while fila:
        vertice = fila.popleft()
        print(vertice, end=" ")  # Processa o vértice
        
        for vizinho, _ in grafo.lista_adjacencia[vertice]:
            if vizinho not in visitado:
                visitado.add(vizinho)
                fila.append(vizinho)

# Exemplo de uso
bfs(grafo, 0)  # Saída: 0 1 2 3
                    </code></pre>
                </div>
            </div>
        </section>

        <section id="algoritmos" class="topic">
            <h2> Algoritmos em Grafos</h2>
            <p>Existem diversos algoritmos importantes que operam sobre grafos para resolver problemas específicos, como
                encontrar componentes conexas, ordenação topológica e detecção de ciclos.
                <br>
                <div class="split-content">
                    <div class="content-left">
                        <h3 class="content-title">Características Principais:</h3>
                        • Algoritmos fundamentados em buscas DFS e BFS<br>
                        • Aplicáveis a grafos direcionados e não-direcionados<br>
                        • Diferentes complexidades dependendo do algoritmo<br>
                        • Essenciais para resolver problemas práticos em computação<br>
            </p>
            </div>
            </div>

            <h3> Algoritmo de Dijkstra</h3>
            <p>O Algoritmo de Dijkstra encontra o caminho mais curto entre um vértice de origem e todos os outros em
                grafos com pesos não-negativos.<br><br>

                <b> Funcionamento:</b><Br><br>

                - Inicializa distâncias: origem = 0, outros = infinito<br>
                - Mantém conjunto de vértices não processados<br>
                - Repetidamente seleciona vértice não processado com menor distância<br>
                - Atualiza distâncias dos vizinhos se um caminho menor for encontrado.<br>
                - Continua até processar todos os vértices<br><br>

                <b> Aplicações:</b><Br><br>
                - Roteamento em redes de computadores (OSPF - Open Shortest Path First)<br>
                - Sistemas GPS e mapas digitais<br>
                - Planejamento de caminhos em robótica<br>
                - Algoritmos de compressão de dados (Huffman utiliza conceitos similares)<br>

            </p>
            <div class="code-examples">
                <div class="code-block">
                    <h3>Exemplo em Python - Dijkstra</h3>
                    <pre><code>
import heapq

def dijkstra(grafo, origem):
    distancias = {i: float('inf') for i in range(grafo.num_vertices)}
    distancias[origem] = 0
    pq = [(0, origem)]
    visitado = set()
    
    while pq:
        dist_atual, u = heapq.heappop(pq)
        
        if u in visitado:
            continue
        visitado.add(u)
        
        for v, peso in grafo.lista_adjacencia[u]:
            if v not in visitado:
                nova_dist = dist_atual + peso
                if nova_dist < distancias[v]:
                    distancias[v] = nova_dist
                    heapq.heappush(pq, (nova_dist, v))
    
    return distancias

# Complexidade: O((V + E) log V) com heap binário
                    </code></pre>
                </div>
            </div>
<br>
            <h3> Algoritmo de Bellman-Ford</h3>
            <p>O Algoritmo de Bellman-Ford encontra o caminho mais curto mesmo em grafos com pesos negativos, mas não
                funciona com ciclos de peso negativo.<br><br>

                <b> Funcionamento:</b><Br><br>

                - Inicializa distâncias: origem = 0, outros = infinito<br>
                - Relaxa todas as arestas V-1 vezes consecutivas<br>
                - Após V-1 iterações, as distâncias mínimas são obtidas<br>
                - Uma iteração adicional pode detectar ciclos negativos<br><br>

                <b> Vantagens sobre Dijkstra:</b><Br><br>

                - Funciona com arestas de peso negativo<br>
                - Detecta ciclos de peso negativo<br>
                - Mais flexível, mas mais lento que Dijkstra<br>

            </p>
            <div class="code-examples">
                <div class="code-block">
                    <h3>Exemplo em Python - Bellman-Ford</h3>
                    <pre><code>
def bellman_ford(grafo, origem):
    distancias = {i: float('inf') for i in range(grafo.num_vertices)}
    distancias[origem] = 0
    
    # Relaxar arestas V-1 vezes
    for _ in range(grafo.num_vertices - 1):
        for u in range(grafo.num_vertices):
            for v, peso in grafo.lista_adjacencia[u]:
                if distancias[u] != float('inf'):
                    if distancias[u] + peso < distancias[v]:
                        distancias[v] = distancias[u] + peso
    
    # Detectar ciclo negativo
    for u in range(grafo.num_vertices):
        for v, peso in grafo.lista_adjacencia[u]:
            if distancias[u] != float('inf'):
                if distancias[u] + peso < distancias[v]:
                    print("Ciclo negativo detectado!")
                    return None
    
    return distancias

# Complexidade: O(V * E)
                    </code></pre>
                </div>
            </div>
<br>
            <h3> Algoritmo de Floyd-Warshall</h3>
            <p>O Algoritmo de Floyd-Warshall é um algoritmo de programação dinâmica que encontra os caminhos mais curtos entre todos os pares de vértices em um grafo ponderado e direcionado. Ele é capaz de lidar com arestas de peso negativo, mas não com ciclos de peso negativo.<br><br>

                <b> Funcionamento:</b><Br><br>

                - Inicializa uma matriz de distâncias com os pesos das arestas diretas e infinito para pares não conectados.<br>
                - Itera sobre todos os vértices (k) e os considera como um vértice intermediário no caminho entre outros dois vértices (i e j).<br>
                - Para cada par (i, j), verifica se o caminho passando por k é mais curto que o caminho direto conhecido.<br>
                - Após iterar por todos os vértices intermediários, a matriz contém os caminhos mais curtos entre todos os pares.<br><br>

                <b> Vantagens:</b><Br><br>

                - Encontra todos os caminhos mínimos de uma só vez.<br>
                - Relativamente simples de implementar.<br>
                - Detecta ciclos negativos<br>

            </p>
            <div class="code-examples">
                <div class="code-block">
                    <h3>Exemplo em Python - Floyd-Warshall</h3>
                    <pre><code>
def floyd_warshall(grafo):
    num_vertices = grafo.num_vertices
    dist = [[float('inf')] * num_vertices for _ in range(num_vertices)]

    for i in range(num_vertices):
        dist[i][i] = 0
        for vizinho, peso in grafo.lista_adjacencia[i]:
            dist[i][vizinho] = peso

    for k in range(num_vertices):
        for i in range(num_vertices):
            for j in range(num_vertices):
                if dist[i][k] + dist[k][j] < dist[i][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]
    
    return dist

# Complexidade: O(V^3)
                    </code></pre>
                </div>
            </div>
        </section>

        <section id="aplicacoes" class="topic">
            <h2> Aplicações de Grafos</h2>
            <p>Grafos têm aplicações extensas em diversos campos da computação e tecnologia. São ferramentas poderosas
                para modelar problemas complexos do mundo real.
                <br>
                <div class="split-content">
                    <div class="content-left">
                        <h3 class="content-title">Aplicações Principais:</h3><br>
                        •  <b>Redes Sociais:</b> Usuários como vértices, amizades/seguimentos como arestas<br>
                        •  <b>Roteamento:</b> Encontrar melhor caminho em redes (GPS, internet)<br>
                        •  <b>Redes de Computadores:</b> Topologia de rede, protocolos de roteamento<br>
                        •  <b>Biologia Computacional:</b> Análise de redes proteicas, filogenética<br>
                        •  <b>Análise de Dependências:</b> Compiladores, gerenciadores de pacotes<br>
                        •  <b>Problemas de Otimização:</b> Caixeiro Viajante (TSP), alocação de recursos<br>
                    </div>
                </div><br>
            </p>

            <h3> Redes Sociais e Análise</h3>
            <p>Grafos são a base para análise de redes sociais, permitindo estudar estruturas de comunidades,
                influenciadores e padrões de propagação.</p>

            <div class="code-examples">
                <div class="code-block">
                    <h3>Análise de Centralidade (Python)</h3><br>
                    <pre><code>
def centralidade_grau(grafo):
    """Retorna o grau de cada vértice"""
    centralidades = {}
    for i in range(grafo.num_vertices):
        centralidades[i] = len(grafo.lista_adjacencia[i])
    return centralidades

def vertices_mais_conectados(grafo, k=3):
    """Retorna os k vértices mais conectados"""
    centralidades = centralidade_grau(grafo)
    return sorted(centralidades.items(), 
                  key=lambda x: x[1], 
                  reverse=True)[:k]

# Exemplo de uso
top_3 = vertices_mais_conectados(grafo, 3)
print("Vértices mais influentes:", top_3)
                    </code></pre>
                </div>
            </div><Br>

            <h3> Problemas Clássicos em Grafos</h3><br>
            <p>• Existem diversos problemas clássicos em teoria dos grafos que têm aplicações práticas importantes e
                servem como base para algoritmos mais avançados.</p>
                <P>
                • O Problema do Caixeiro Viajante (PCV) é um problema clássico de otimização combinatória que busca encontrar a rota mais curta possível para um caixeiro visitar um conjunto de cidades, retornando sempre à cidade de origem após visitar cada cidade exatamente uma vez. Ele é extremamente complexo e classificado como NP-difícil, o que significa que encontrar uma solução ótima para um grande número de cidades é computacionalmente inviável. </P>


            <div class="code-examples">
                <div class="code-block">
                    <h3>Problema do Caixeiro Viajante - Aproximação</h3>
                    <pre><code>
def tsp_aproximacao_gulosa(matriz_distancias, inicio=0):
    """Aproximação gulosa para o Caixeiro Viajante"""
    n = len(matriz_distancias)
    visitado = [False] * n
    visitado[inicio] = True
    rota = [inicio]
    custoTotal = 0
    
    while len(rota) < n:
        ultimo = rota[-1]
        proximo = -1
        menorDist = float('inf')
        
        for j in range(n):
            if not visitado[j] and matriz_distancias[ultimo][j] < menorDist:
                menorDist = matriz_distancias[ultimo][j]
                proximo = j
        
        rota.append(proximo)
        visitado[proximo] = True
        custoTotal += menorDist
    
    # Voltar ao vértice inicial
    custoTotal += matriz_distancias[rota[-1]][inicio]
    
    return rota, custoTotal

# TSP é NP-completo, aproximações são frequentemente usadas
                    </code></pre>
                </div>
            </div>
        </section>
    </main>

    <footer>
        <p> Luana Santini: Sistemas de Informação - Estácio Florianópolis - Matrícula 202308416251</p>
    </footer>
</body>